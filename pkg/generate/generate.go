package generate

import (
	"errors"
	"fmt"
	"os"
	"sort"

	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"

	"github.com/newrelic/tutone/internal/schema"
)

// The big show
func Generate() error {
	fmt.Print("\n GENERATE..... \n")

	defFile := viper.GetString("definition")
	schemaFile := viper.GetString("schema_file")
	typesFile := viper.GetString("generate.types_file")
	// packageName := viper.GetString("package")

	log.WithFields(log.Fields{
		"definition_file": defFile,
		"schema_file":     schemaFile,
		"types_file":      typesFile,
	}).Info("Loading generation config")

	// load the config
	cfg, err := LoadConfig(defFile)
	if err != nil {
		return err
	}

	// CLI Overrides
	// if packageName != "" {
	// 	cfg.Package = packageName
	// }

	// package is required
	if len(cfg.Packages) == 0 {
		return errors.New("an array of package names is required")
	}

	// Load the schema
	s, err := schema.Load(schemaFile)
	if err != nil {
		return err
	}
	log.WithFields(log.Fields{
		"schema": s,
	}).Trace("loaded schema")

	doGenerate(s, cfg)

	return errors.New("not implemented")
}

func generateTypesForPackage(pkg Package, schemaInput *schema.Schema) {
	// TODO: Putting the types in the specified path should be optional
	//       Should we use a flag or allow the user to omit that field in the config?
	if _, err := os.Stat(pkg.Path); os.IsNotExist(err) {
		if err := os.Mkdir(pkg.Path, 0755); err != nil {
			log.Error(err)
		}
	}

	filePath := fmt.Sprintf("%s/types.go", pkg.Path)
	f, err := os.Create(filePath)
	if err != nil {
		log.Error(err)
	}

	_, err = f.WriteString(fmt.Sprintf("// Code generated by typegen; DO NOT EDIT.\n\npackage %s\n\n", pkg.Name))
	if err != nil {
		log.Error(err)
	}

	defer f.Close()

	// RODO: Imports?? Check old implementation

	keys := make([]string, 0, len(schema.Types))
	for k := range schema.Types {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		_, err := f.WriteString(schema.Types[k])
		if err != nil {
			log.Error(err)
		}
	}
}

func doGenerate(schemaInput *schema.Schema, config *Config) {
	for _, pkg := range config.Packages {
		if err := schema.ResolveSchemaTypes(*schemaInput, pkg.Types); err != nil {
			log.Error(err)
		}

		// TODO: Update return pattern to be tuple - e.g. (result, err)
		generateTypesForPackage(pkg, schemaInput)
	}
}
