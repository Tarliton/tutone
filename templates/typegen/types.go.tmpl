// Code generated by tutone: DO NOT EDIT
package {{.PackageName}}

{{- if gt (len .Imports) 0 }}
import(
  {{- range .Imports}}
  "{{.}}"
  {{- end}}
)
{{- end}}

{{- range .Enums }}
{{ .Description }}
type {{ .Name }} string
{{ $typeName := .Name }}

var {{.Name}}Types = struct {
  {{- range .Values }}
	{{ .Description }}
	{{ .Name }} {{ $typeName }}
  {{- end}}
}{
  {{- range .Values }}
	{{ .Description }}
	{{ .Name }}: "{{ .Name }}",
  {{- end}}
}
{{- end}}

{{- range .Types }}
{{ .Description }}
{{- $typeName := .Name }}
type {{.Name}} struct {
  {{- range .Fields }}
  {{ .Description }}
  {{ .Name }} {{ .Type }} {{ .Tags }}
  {{- end}}
}

{{   range .Implements }}
func (x *{{ $typeName }}) Implements{{ . }}() {}
{{   end }}

{{-  if .SpecialUnmarshal }}
// special
func (x *{{ $typeName }}) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}

	for k, v := range objMap {
		switch k {
  {{- range .Fields }}
    {{- $field := . }}
		case "{{ .TagKey }}":
    {{- if .IsInterface }}
      {{- if .IsList }}
        var rawMessage{{ .Name }} []*json.RawMessage
        err = json.Unmarshal(*v, &rawMessage{{ .Name }})
        if err != nil {
          return err
        }

        for _, m := range rawMessage{{ .Name }} {
          xxx, err := Unmarshal{{ $field.TypeName }}Interface(*m)
          if err != nil {
            return err
          }

          if xxx != nil {
            x.{{ $field.Name }} = append(x.{{ $field.Name }}, *xxx)
          }
        }


      {{- else }}
        xxx, err := Unmarshal{{ $field.TypeName }}Interface(*v)
        if err != nil {
          return err
        }

        if xxx != nil {
          x.{{ $field.Name }} = *xxx
        }
      {{- end }}
    {{- else }}
			err = json.Unmarshal(*v, &x.{{ .Name }})
			if err != nil {
				return err
			}
    {{- end }}
  {{- end }}
		}
	}

  return nil
}
{{   end}}
{{ end}}

{{- range .Scalars }}
{{ .Description }}
type {{.Name}} {{.Type}}
{{- end}}

{{- range .Interfaces }}
{{- $interfaceType := . }}
{{ .Description }}
type {{ $interfaceType.Name }}Interface interface{
  Implements{{.Name}}()
}

//yes
func Unmarshal{{ $interfaceType.Name }}Interface(b []byte) (*{{ $interfaceType.Name }}Interface, error) {
  var err error

  var rawMessage{{ $interfaceType.Name }} map[string]*json.RawMessage
  err = json.Unmarshal(b, &rawMessage{{ $interfaceType.Name }})
  if err != nil {
    return nil, err
  }

  var typeName string

  if rawTypeName, ok := rawMessage{{ $interfaceType.Name }}["__typename"]; ok {
    err = json.Unmarshal(*rawTypeName, &typeName)
    if err != nil {
      return nil, err
    }

    switch typeName {
  {{- range .PossibleTypes }}
    case "{{ .GraphQLName }}":
      var interfaceType {{ .GoName }}
      err = json.Unmarshal(b, &interfaceType)
      if err != nil {
        return nil, err
      }

      var xxx {{ $interfaceType.Name }}Interface = &interfaceType

      return &xxx, nil
  {{- end }}
    }
  } else {
    keys := []string{}
    for k := range rawMessage{{ $interfaceType.Name }} {
      keys = append(keys, k)
    }
    return nil, fmt.Errorf("interface {{ $interfaceType.Name }} did not include a __typename field for inspection: %s", keys)
  }

  return nil, fmt.Errorf("interface {{ $interfaceType.Name }} was not matched against all PossibleTypes: %s", typeName)
}
{{-  end }}
